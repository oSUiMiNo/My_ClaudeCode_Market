# Codex議論ログ

- **日時**: 2026-01-26 02:59:47
- **トピック**:
  - PTYセッション機能の設計・実装レビュー
  - セッション永続化の設計ギャップ（プロセス間再接続が不可能）
  - 実装上のバグ（await欠落、終了処理の非同期問題、競合状態）
  - 運用上の問題（npxの不安定性、プロセスツリーの孤児化、文字コード）
  - 改善提案（アーキテクチャ一本化、TUI出力処理、入力注入の堅牢化）
- **目的**: node-ptyを使ったPTYセッション機能の設計・実装の問題点を洗い出し、改善点を議論する
- **Codexセッション**: 019bfb78-f082-7d13-be6e-67a76ef1ebb3
- **作業ディレクトリ**: なし <!-- questionモードは「なし」でOK、review/modifyは必須 -->
- **sandbox**: read-only
- **Codex向けマインドセット**:
  - 迎合せず、根拠で検討する。同意する場合も反論を試みた上で行う
  - 判断や提案が絡む場合は、反証や代替案を検討する。提示不可なら明示する
  - 不確実性は明示し、断定を避ける
  - 反論するために無理やり反論するのは禁止
- **参照パス**:
  - .claude/skills/codex/scripts/pty-session.mjs
  - .claude/skills/codex/scripts/codex-helper.mjs

---

## Claude → Codex (1)

PTYセッション機能（node-ptyを使ったCodex CLIのインタラクティブモード制御）の設計・実装について、レビューをお願いしたい。

### 実装概要

参照パスのファイルを読んで確認してほしい。主な実装内容は以下の通り:

1. **CodexPtyクラス** (`pty-session.mjs`):
   - node-ptyでCodex CLIを起動
   - `--search`フラグでWeb検索を有効化
   - `send()`で入力送信、`collectOutput()`で出力収集
   - セッション情報をJSONファイルで永続化

2. **codex-helper.mjs側の統合**:
   - `start-session`: PTYセッション開始
   - `send`: セッションに入力送信
   - `end-session`: セッション終了
   - `list-sessions`: アクティブセッション一覧

### レビュー観点

以下の観点で問題点・改善点を指摘してほしい:

1. **設計上の問題**:
   - アーキテクチャの問題点
   - 責務の分離は適切か
   - セッション管理の設計は妥当か

2. **実装上の問題**:
   - バグの可能性がある箇所
   - エラーハンドリングの不備
   - 競合状態やメモリリーク

3. **運用上の問題**:
   - 実際に使う場面で困りそうな点
   - ログ/デバッグの観点
   - クロスプラットフォーム対応

4. **改善提案**:
   - 具体的な改善案（優先度付き）

## Codex → Claude (1)

**session_id**: 019bfb78-f082-7d13-be6e-67a76ef1ebb3

### 結論（最重要の設計ギャップ）

現状の `start-session` / `send` / `end-session` は「別プロセスから同じ PTY に再接続して使う」前提に見えるが、実装はそれを実現できない。

- `activeSessions` はプロセス内 `Map` で、`node codex-helper.mjs ...` を叩くたびに消える（`codex-helper.mjs:634`, `codex-helper.mjs:679`）
- `pty-session.mjs` 側がモジュールロード時に `process.on('exit', ...)` で全セッション終了を仕込んでいるため、`start-session` 実行後に `codex-helper` が終了すると、セッションも終了する（`pty-session.mjs:379`）
- つまり「常駐セッションで複数ラリー」になっておらず、現状は `runWithPty` が"1回実行してkillする"ユーティリティと、動かないセッションAPIが混在している

---

### 設計上の問題

1. **セッション永続の境界が曖昧**: `pty-session.mjs` はライブラリなのにプロセス終了フックを勝手に登録している（`pty-session.mjs:379`）。呼び出し側の寿命・シグナル設計と衝突しやすい

2. **「セッション情報ファイル」の役割が中途半端**: `sessions/*.json` に `pid` などを書くが、別プロセスからその PID の ConPTY に"再アタッチ"はできない。現状の `send` はディスクを見ず `getActiveSession()` しか使わない

3. **TUIを"ログ文字列"として扱う限界**: Codex CLI はフルスクリーンTUIで再描画が多いため、`outputBuffer += data` は重複・スピナー・画面更新で肥大化しやすく、`strip-ansi` しても「人間が見たい最終テキスト」になりにくい

---

### 実装上のバグ/危険箇所

1. **`sendToSession` が `await` していない**: `ptySession.send(prompt);` の戻り（Promise）を待たずに `collectOutput` へ進む（`codex-helper.mjs:704`）。入力が送信完了する前に空レスになり得る

2. **終了処理がほぼ効かない可能性**: `kill()` が `setTimeout(... ptyProcess.kill())` 依存なのに、`exit`/`SIGINT`/`SIGTERM` で `process.exit()` を即呼びしているため、タイマーが動かず子プロセスが残る（孤児化）リスクが高い

3. **`SESSIONS_DIR` 未作成でクラッシュし得る**: `spawn()` の `setTimeout` 内で `_saveSessionFile()` を呼ぶが、`SESSIONS_DIR` が無いと `writeFileSync` が例外で落ちる

4. **出力終端判定が脆い**: `collectOutput()` が「一定時間出力が増えない」で完了判定。TUIの再描画/間欠出力/長考で、早すぎ終了・永遠に終わらないの両方が起こり得る

5. **入力制御が危険**: 毎回 `ESC` + `Ctrl+U` を送る。Codex TUIの状態によってはショートカットが別機能に割り当たっていて誤動作する

6. **同時実行に弱い**: `outputBuffer` を共有して都度クリア。並列 `send` が入ると競合して壊れる（キュー/ロック無し）

7. **Windows文字コード問題**: `cmd.exe` 経由で `npx ...` を起動しているが、`chcp 65001` 等をしていないので日本語が文字化けしやすい

---

### 運用上の問題

1. **`npx @openai/codex` は運用が不安定/遅い**: バージョンが固定されず、初回DL・キャッシュ破損・ネットワークで挙動が変わる

2. **PIDの扱いが不十分**: Windowsでは `cmd.exe` → `npx` → `node` の木になる。`ptyProcess.kill()` がツリー全体を確実に落とせないと孤児が残りやすい

3. **24時間TTLは常駐思想と衝突**: 常駐を想定するなら、`started_at` だけでファイルを消すのは誤削除になり得る（"稼働中セッション"でも消える）

---

### 改善提案（優先度付き）

**P0: 即修正が必要**
- `sendToSession` の `ptySession.send(prompt)` を必ず `await`
- `pty-session.mjs` の `process.on('exit', ...)` で非同期終了しない。終了責務は呼び出し側へ寄せ、`kill()` は即時確実に落とす経路（Windowsなら `taskkill /T /F` 相当）を用意

**P1: アーキテクチャ一本化**
- 「再接続不要」なら、`start-session` はプロセスを終了せず常駐し、同一プロセス内で `send` を受ける形に寄せる（例: stdin でJSON行を受け付ける"サーバー"モード）
- 「別プロセス呼び出し」で使いたいなら、デーモン（常駐）+ IPC（named pipe等）が必要

**P2: TUI出力の取り扱い改善**
- 文字列連結バッファではなく、端末エミュレータ（xterm.js headless等）で画面状態を復元して必要部分を抽出するか、リングバッファ化＋最大サイズ制限を入れる
- "完了判定"は「静寂時間」だけでなく、プロンプト復帰検知や二段階待機にする

**P3: 入力注入の堅牢化**
- `ESC`/`Ctrl+U` 依存をやめ、bracketed paste（対応TUIが多い）や送信キュー（1 in-flight）で取りこぼしを防ぐ
- 文字送り10ms固定は長文で遅すぎるので、ペースト方式に寄せる

**P4: Windows 11向け運用強化**
- `cmd.exe` を使うなら UTF-8 化（`chcp 65001`）を仕込む／あるいは PowerShell を使う
- `npx` ではなく `@openai/codex` を依存に入れてローカル実行（バージョン固定）し、起動を安定化

<!-- ラリー継続が必要な場合のみ (2), (3)... を追加。1回で完結するなら追加不要。 -->

## 結論

### 核心的な問題

PTYセッション機能の最大の問題は**設計上のギャップ**である。現状の `start-session` / `send` / `end-session` コマンドは「別プロセスから同じPTYに再接続する」前提の設計に見えるが、実装はそれを実現できていない。

- `activeSessions` はプロセス内 `Map` であり、CLIコマンドを実行するたびにリセットされる
- `process.on('exit')` でセッション終了が仕込まれており、コマンド終了時にセッションも終了する
- 結果として「常駐セッションで複数ラリー」は実現できておらず、`runWithPty` の「1回実行してkill」と、動作しないセッションAPIが混在している

### 即修正が必要なバグ（P0）

1. `sendToSession` で `ptySession.send(prompt)` を `await` していない（空レス発生の原因）
2. `kill()` がsetTimeout依存なのに `process.exit()` を即呼びしており、子プロセスが孤児化するリスク

### アーキテクチャの選択肢

| 方式 | メリット | 実装コスト |
|------|---------|-----------|
| **常駐サーバーモード** | stdin/stdoutでJSON行を受け付け、同一プロセス内でセッション維持 | 中（既存コードの再構成） |
| **デーモン+IPC** | 別プロセスから `send` 可能 | 高（named pipe等の実装が必要） |
| **1回実行方式に割り切り** | シンプル、現状の `runWithPty` を整備 | 低（バグ修正のみ） |

### 推奨アクション

1. まずP0バグを修正（await追加、kill同期化）
2. 運用方針を決定（常駐 vs 1回実行）
3. 選択した方針に合わせてアーキテクチャを一本化

**次のアクション**: P0バグの修正（`sendToSession` の await 追加、終了処理の同期化）を実施するか、運用方針の決定を先に行う
