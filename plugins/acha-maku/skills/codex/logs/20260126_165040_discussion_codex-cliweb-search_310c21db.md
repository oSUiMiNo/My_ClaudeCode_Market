# Codex議論ログ

- **日時**: 2026-01-26 16:50:40
- **トピック**:
  - Codex CLIのWeb Search機能について
  - codexスキルのアーキテクチャ変更（exec vs インタラクティブ）
  - MCP連携によるWeb検索の実現方法
- **目的**: Codex CLIにWeb Search機能があるか、ある場合の使い方、ない場合の代替手段を確認する。また、現行のexecモードベースのアーキテクチャを改善する方針を決定する
- **Codexセッション**: なし（CLIヘルプからの事実確認のためCodex呼び出し不要）
- **作業ディレクトリ**: なし <!-- questionモードは「なし」でOK、review/modifyは必須 -->
- **sandbox**: read-only
- **Codex向けマインドセット**:
  - 迎合せず、根拠で検討する。同意する場合も反論を試みた上で行う
  - 判断や提案が絡む場合は、反証や代替案を検討する。提示不可なら明示する
  - 不確実性は明示し、断定を避ける
- **参照パス**:
  - なし

---

## Claude → Codex (1)

Codex CLI（OpenAI）のWeb Search機能について質問がある。

### 質問

1. **Codex CLIにWeb Search機能はあるか？**
   - 公式にサポートされている機能か？
   - `codex`コマンドまたはその設定でWeb検索を有効化できるか？

2. **ある場合、どのように有効化・使用するか？**
   - コマンドラインオプション
   - 設定ファイル（例：`.codex/config.yaml`など）
   - 環境変数

3. **ない場合、代替手段はあるか？**
   - MCP（Model Context Protocol）連携でWeb検索ツールを追加する方法
   - 外部ツール呼び出しや拡張機能
   - Responses APIのweb_search_preview機能との関係

### 背景

OpenAIのResponses APIにはweb_search_previewツールが存在するが、Codex CLIがこれをサポートしているかは不明。Claude CodeにはWebSearchツールがあるため、Codex CLIでも同様の機能が使えるか確認したい。

## 調査結果（CLIヘルプからの事実確認）

Codex CLIの`--help`出力を調査した結果、以下が判明した。

### 1. Codex CLIにWeb Search機能はあるか？

**はい、公式サポートされている。**

```
--search
    Enable live web search. When enabled, the native Responses `web_search` tool is available
    to the model (no per‑call approval)
```

### 2. 有効化・使用方法

#### コマンドラインオプション
```bash
npx @openai/codex --search "検索を含む質問"
```

インタラクティブモードで`--search`フラグを付けると、Responses APIの`web_search`ツールがモデルに利用可能になる。承認なしでWeb検索が実行される。

#### 制限事項
- **`codex exec`（非インタラクティブモード）には`--search`オプションがない**
- インタラクティブモードのみで利用可能

#### 設定ファイル
`~/.codex/config.toml`で設定可能と推測される（`-c`オプションで上書き可能なため）が、具体的なキー名は要確認。

### 3. 代替手段

#### MCP（Model Context Protocol）連携
Codex CLIはMCPを実験的にサポートしている。

```bash
# MCP追加
codex mcp add <name> --url <URL>
codex mcp add <name> -- <command>...

# MCP一覧
codex mcp list
```

Web検索機能を持つMCPサーバー（例：Brave Search MCP）を追加することで、`exec`モードでもWeb検索を間接的に利用可能。

#### Responses APIとの関係
`--search`は内部的にResponses APIの`web_search`ツールを有効化する。CLIはResponses APIのラッパーとして機能。

## 結論

### Web Search機能について
1. **Web Search機能は存在する**: `--search`フラグで有効化
2. **インタラクティブモードのみ対応**: `codex exec`（非インタラクティブ）では利用不可
3. **代替手段としてMCP連携が可能**: Web検索MCPサーバーを追加することで`exec`モードでも検索可能

### アーキテクチャ方針
**採用案: ハイブリッドアプローチ（用途で使い分け）**

1. **現行のexecモードは維持** - 安定性と再現性を確保
2. **MCP連携を追加** - Brave Search MCPで`exec`モードでもWeb検索可能に
3. **インタラクティブモードは探索用途に限定** - 新機能の調査や試行錯誤に使用

### 次のアクション
1. `mcp.json` にBrave Search MCPを追加（`BRAVE_API_KEY`環境変数が必要）
2. `codex-helper.mjs` を改修し、MCP設定を読み込むように変更
3. 必要に応じてインタラクティブモードを手動で使用（自動化は見送り）

---

## Claude → Codex (2)

現在のcodexスキルのアーキテクチャ変更について議論したい。

### 現状
- `codex exec`（非インタラクティブモード）を使用
- 1ラリーごとにCodexを起動し直す
- 継続時はログ全体を読ませて再開
- `--search`（Web検索）が使えない（execモード非対応）

### 提案
- インタラクティブモード（`codex --search`）を使って、1回のセッションで数ラリーを実行
- 再開時は新しいインタラクティブセッションでログを見せて再開

### 検討してほしい点
1. この提案のメリット・デメリット
2. インタラクティブモードをスクリプトから自動化する方法はあるか？
3. トークン効率とコンテキストの質は本当に向上するか？
4. 実装上の課題は何か？

## Codex → Claude (2)

**session_id**: 019bfb14-41c6-7301-b021-c8f49e5a2042

**結論の要点**
- 目的が「検索を使いたい」「連続ラリーでの文脈維持」ならインタラクティブ化は有効。ただし自動化と再現性が犠牲になりやすい。

### 1. メリット/デメリット
- **メリット**: `--search`が使える、同一セッションで会話文脈が保たれる、ログ再読の手間とノイズ削減。
- **デメリット**: 非決定性が増える（検索結果/タイミング）、自動化が難しい、セッション切替時の状態管理が複雑、障害時のリカバリが面倒。

### 2. インタラクティブをスクリプト自動化できるか
- 可能性はあるが堅牢性は低め。一般的には以下のいずれか:
  - 擬似端末（PTY）を使った制御（expect/pexpectなど）
  - TTY入力の自動化（PowerShellなら `Start-Process` + 標準入出力制御）
- ただしUI変更に弱く、保守コスト高。安定運用を重視するなら「exec継続＋外部要約＋検索代替」の方が安全。

### 3. トークン効率/コンテキスト品質は向上するか
- 短期的には向上しやすい（同一セッション内での冗長再掲が減る）。
- ただしセッション再開時は「ログ再読」の問題が残るので、改善幅は限定的。
- 効率の鍵は「要約の質と再掲の粒度」。インタラクティブ化だけでは根本改善になりにくい。

### 4. 実装上の課題
- セッション管理（開始/終了/再開の状態管理）
- ログの構造化（検索履歴・外部参照の追跡）
- 失敗時の復旧（同一セッションに依存するほど難化）
- 自動化の壊れやすさ（PTY制御、プロンプト検出など）

### 提案方向性
- 「searchを使いたい」なら、インタラクティブ化は有効。ただし運用コストが上がる前提で設計。
- 安定運用重視なら「exec継続＋要約レイヤ（ログ→短要約）」が堅実。

---

## Claude → Codex (3)

前回の議論の続き。以下の点について深掘りしたい。

### 質問

1. **exec継続+要約レイヤという代替案について**：具体的にどのような実装になるか？要約はいつ誰が生成するのか？Claude側？Codex側？別のモデル？
2. **Node.jsでPTY制御を実装する場合**、node-ptyなどのライブラリを使えば比較的容易ではないか？実際の難易度を教えてほしい。
3. **現在の問題は「Web検索がexecモードで使えない」ことが起点**。これを解決する方法として、インタラクティブ化以外にMCP連携（例：Brave Search MCP）という選択肢もあると思うが、この比較検討をしてほしい。

## Codex → Claude (3)

**session_id**: 019bfb15-0182-7e40-8fb1-aa86cd1218c5

### 1. exec継続＋要約レイヤ案（実装イメージ／要約生成者）
- **目的**: execの非対話性を維持しつつ、長い履歴や複数ステップの文脈を圧縮して"再投入"できるようにする。
- **典型実装**:
  - Exec実行ログを全て保存（コマンド、出力、失敗理由）。
  - 一定トリガー（トークン逼迫、ステップ完了、エラー多発など）で「要約生成」。
  - 要約を"会話状態"として新しいexecセッションに注入。
- **生成タイミング**:
  - 自動: ランタイムが閾値で発火（トークン・長さ・タスク境界）。
  - 手動: ユーザーが「要約して継続」と指示。
- **生成主体の選択肢**:
  - Claude側: 低遅延・統合容易だが、モデル依存が強い。
  - Codex側: 実装制御は強いが、要約品質に工夫が必要。
  - 別モデル: コスト最適化・分離可能だが構成が複雑。
- **実務的結論**: 「既存モデルで要約→短い"作業状態メモ"として再注入」が最速。品質が足りなければ専用モデルに分離。

### 2. Node.jsでPTY制御（node-pty等）の難易度
- ライブラリ導入自体は容易（node-ptyは成熟）。**難しいのは運用面**。
- **主な難所**:
  - クロスプラットフォーム差（Windows ConPTY、Linux/macOSのPTY挙動差）。
  - 入出力ストリームの行制御・エスケープシーケンス処理。
  - 長時間セッションの安定性（切断、再接続、ハングの処理）。
  - セキュリティ（任意コマンド実行、権限境界）。
- **結論**: "動くものを作る"は容易。"堅牢な対話型基盤"に仕上げるのは中〜高難易度。

### 3. 「Web検索がexecで使えない」問題の解法比較

| 観点 | インタラクティブ化（PTY） | MCP連携（Brave Search等） |
|------|--------------------------|--------------------------|
| 長所 | 既存CLI操作のままWeb検索コマンドを通せる | Web検索を安全かつ構造化で利用可能。非対話でも成立 |
| 短所 | セッション管理・安全性・UI制御の難易度が上がる | MCPサーバーの運用/設定が必要。検索結果の解釈は別途設計 |
| 適性 | "同一UXで全て実行"を最優先したい場合 | "execのまま安全に検索を使いたい"場合の最短解 |

**まとめ**: 問題起点が「execでWeb検索不可」なら、**まずMCP連携が低リスク**。将来的に統一UXを求めるならインタラクティブ化を検討。

---

## Claude → Codex (4)

結論を出すための最終質問。

### 質問

1. **MCP連携の具体的な設定方法を教えてほしい**。Codex CLIでBrave Search MCPを使う場合、どのようなコマンドで設定するか？
2. **現行のcodex-helper.mjs（execモードでCodexを呼び出すスクリプト）にMCP連携を追加する場合**、どのような改修が必要か？
3. **推奨するアーキテクチャ案を提示してほしい**。現在のexecベースを維持しつつMCP連携を追加するか、それともインタラクティブに移行するか、あるいはハイブリッド（用途で使い分け）か。

## Codex → Claude (4)

**session_id**: 019bfb16-8d04-7c02-aa2b-e8b6cc6df341

### 1. MCP連携の具体的な設定（Brave Search MCP）

前提: Brave SearchのAPIキーを `BRAVE_API_KEY` で環境変数として渡せること。

**mcp.json の設定例**（既存の `mcp.json` に追記）:
```json
{
  "mcpServers": {
    "brave-search": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-brave-search"]
    }
  }
}
```

**PowerShellでの起動例**:
```powershell
$env:BRAVE_API_KEY="YOUR_BRAVE_API_KEY"
codex --mcp-config .\mcp.json
```

補足: Codexがカレントの `mcp.json` を自動検出する仕様なら、`codex` 単体でOK。自動検出かどうかが不明なら、`--mcp-config` 指定が安全。

### 2. codex-helper.mjs へのMCP追加の改修ポイント

**必須改修**:
- `codex` 実行コマンドに `--mcp-config <path>` を追加
- `BRAVE_API_KEY` を `exec` / `spawn` の `env` に注入
- `mcp.json` のあるディレクトリで `cwd` を固定

**概念コード例**:
```js
const env = { ...process.env, BRAVE_API_KEY: process.env.BRAVE_API_KEY };
const cmd = `codex --mcp-config ${mcpConfigPath} ${otherArgs}`;
exec(cmd, { cwd: repoRoot, env }, callback);
```

**任意改修**:
- `--mcp-config` をCLI引数 or .envから渡せるようにする
- APIキー未設定時に明確なエラーメッセージを出す

### 3. 推奨アーキテクチャ案

**Codexの推奨: ハイブリッド（用途で使い分け）**

| アプローチ | 強み | 弱み |
|-----------|------|------|
| exec維持 | CI/バッチ/自動化に最適、再現性が高い | MCPツールの探索・対話的調整がしづらい |
| インタラクティブ移行 | MCPツールの探索がしやすい、試行錯誤が速い | 自動化・統合が弱い |
| ハイブリッド | 探索はインタラクティブ、運用はexecで固められる | 実務的には最も安定 |

**おすすめ運用**:
- 調査や検索（Brave Search）はインタラクティブで探索
- 安定した手順は `codex-helper.mjs` に落としてexec運用
